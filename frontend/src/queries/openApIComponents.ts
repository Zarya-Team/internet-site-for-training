/**
 * Generated by @openapi-codegen
 *
 * @version 0.0.1
 */
import * as reactQuery from "@tanstack/react-query";
import { useOpenApIContext, OpenApIContext } from "./openApIContext";
import type * as Fetcher from "./openApIFetcher";
import { openApIFetch } from "./openApIFetcher";
import type * as Schemas from "./openApISchemas";

export type CountriesGetAllCountriesGetError = Fetcher.ErrorWrapper<undefined>;

export type CountriesGetAllCountriesGetResponse = Schemas.CountriesSchema[];

export type CountriesGetAllCountriesGetVariables =
  OpenApIContext["fetcherOptions"];

export const fetchCountriesGetAllCountriesGet = (
  variables: CountriesGetAllCountriesGetVariables,
  signal?: AbortSignal
) =>
  openApIFetch<
    CountriesGetAllCountriesGetResponse,
    CountriesGetAllCountriesGetError,
    undefined,
    {},
    {},
    {}
  >({ url: "/countries", method: "get", ...variables, signal });

export const useCountriesGetAllCountriesGet = <
  TData = CountriesGetAllCountriesGetResponse
>(
  variables: CountriesGetAllCountriesGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      CountriesGetAllCountriesGetResponse,
      CountriesGetAllCountriesGetError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useOpenApIContext(options);
  return reactQuery.useQuery<
    CountriesGetAllCountriesGetResponse,
    CountriesGetAllCountriesGetError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/countries",
      operationId: "countriesGetAllCountriesGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchCountriesGetAllCountriesGet(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type AddToFavouritesFavouritesRecipeIdPostPathParams = {
  recipeId: number;
};

export type AddToFavouritesFavouritesRecipeIdPostError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type AddToFavouritesFavouritesRecipeIdPostVariables = {
  pathParams: AddToFavouritesFavouritesRecipeIdPostPathParams;
} & OpenApIContext["fetcherOptions"];

export const fetchAddToFavouritesFavouritesRecipeIdPost = (
  variables: AddToFavouritesFavouritesRecipeIdPostVariables,
  signal?: AbortSignal
) =>
  openApIFetch<
    void,
    AddToFavouritesFavouritesRecipeIdPostError,
    undefined,
    {},
    {},
    AddToFavouritesFavouritesRecipeIdPostPathParams
  >({ url: "/favourites/{recipeId}", method: "post", ...variables, signal });

export const useAddToFavouritesFavouritesRecipeIdPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      AddToFavouritesFavouritesRecipeIdPostError,
      AddToFavouritesFavouritesRecipeIdPostVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useOpenApIContext();
  return reactQuery.useMutation<
    void,
    AddToFavouritesFavouritesRecipeIdPostError,
    AddToFavouritesFavouritesRecipeIdPostVariables
  >({
    mutationFn: (variables: AddToFavouritesFavouritesRecipeIdPostVariables) =>
      fetchAddToFavouritesFavouritesRecipeIdPost({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type RemoveFromFavouritesFavouritesRecipeIdDeletePathParams = {
  recipeId: number;
};

export type RemoveFromFavouritesFavouritesRecipeIdDeleteError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type RemoveFromFavouritesFavouritesRecipeIdDeleteVariables = {
  pathParams: RemoveFromFavouritesFavouritesRecipeIdDeletePathParams;
} & OpenApIContext["fetcherOptions"];

export const fetchRemoveFromFavouritesFavouritesRecipeIdDelete = (
  variables: RemoveFromFavouritesFavouritesRecipeIdDeleteVariables,
  signal?: AbortSignal
) =>
  openApIFetch<
    void,
    RemoveFromFavouritesFavouritesRecipeIdDeleteError,
    undefined,
    {},
    {},
    RemoveFromFavouritesFavouritesRecipeIdDeletePathParams
  >({ url: "/favourites/{recipeId}", method: "delete", ...variables, signal });

export const useRemoveFromFavouritesFavouritesRecipeIdDelete = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      RemoveFromFavouritesFavouritesRecipeIdDeleteError,
      RemoveFromFavouritesFavouritesRecipeIdDeleteVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useOpenApIContext();
  return reactQuery.useMutation<
    void,
    RemoveFromFavouritesFavouritesRecipeIdDeleteError,
    RemoveFromFavouritesFavouritesRecipeIdDeleteVariables
  >({
    mutationFn: (
      variables: RemoveFromFavouritesFavouritesRecipeIdDeleteVariables
    ) =>
      fetchRemoveFromFavouritesFavouritesRecipeIdDelete({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetFavouritesFavouritesGetError = Fetcher.ErrorWrapper<undefined>;

export type GetFavouritesFavouritesGetVariables =
  OpenApIContext["fetcherOptions"];

export const fetchGetFavouritesFavouritesGet = (
  variables: GetFavouritesFavouritesGetVariables,
  signal?: AbortSignal
) =>
  openApIFetch<void, GetFavouritesFavouritesGetError, undefined, {}, {}, {}>({
    url: "/favourites",
    method: "get",
    ...variables,
    signal,
  });

export const useGetFavouritesFavouritesGet = <TData = void>(
  variables: GetFavouritesFavouritesGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<void, GetFavouritesFavouritesGetError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useOpenApIContext(options);
  return reactQuery.useQuery<void, GetFavouritesFavouritesGetError, TData>({
    queryKey: queryKeyFn({
      path: "/favourites",
      operationId: "getFavouritesFavouritesGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetFavouritesFavouritesGet(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type CountriesRecipesGetAllCountriesRecipesGetQueryParams = {
  countries_id: number;
  /**
   * Номер страницы, стандартно 1
   *
   * @default 1
   */
  page?: number;
  /**
   * Количество выгружаемных рецептов, стандартно 5
   *
   * @default 5
   */
  per_page?: number;
};

export type CountriesRecipesGetAllCountriesRecipesGetError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type CountriesRecipesGetAllCountriesRecipesGetResponse =
  Schemas.RecipesSchema[];

export type CountriesRecipesGetAllCountriesRecipesGetVariables = {
  queryParams: CountriesRecipesGetAllCountriesRecipesGetQueryParams;
} & OpenApIContext["fetcherOptions"];

export const fetchCountriesRecipesGetAllCountriesRecipesGet = (
  variables: CountriesRecipesGetAllCountriesRecipesGetVariables,
  signal?: AbortSignal
) =>
  openApIFetch<
    CountriesRecipesGetAllCountriesRecipesGetResponse,
    CountriesRecipesGetAllCountriesRecipesGetError,
    undefined,
    {},
    CountriesRecipesGetAllCountriesRecipesGetQueryParams,
    {}
  >({ url: "/countries_recipes", method: "get", ...variables, signal });

export const useCountriesRecipesGetAllCountriesRecipesGet = <
  TData = CountriesRecipesGetAllCountriesRecipesGetResponse
>(
  variables: CountriesRecipesGetAllCountriesRecipesGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      CountriesRecipesGetAllCountriesRecipesGetResponse,
      CountriesRecipesGetAllCountriesRecipesGetError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useOpenApIContext(options);
  return reactQuery.useQuery<
    CountriesRecipesGetAllCountriesRecipesGetResponse,
    CountriesRecipesGetAllCountriesRecipesGetError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/countries_recipes",
      operationId: "countriesRecipesGetAllCountriesRecipesGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchCountriesRecipesGetAllCountriesRecipesGet(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type CategoriesRecipesGetAllCategoriesRecipesGetQueryParams = {
  categories_id: number;
  /**
   * Номер страницы, стандартно 1
   *
   * @default 1
   */
  page?: number;
  /**
   * Количество выгружаемных рецептов, стандартно 5
   *
   * @default 5
   */
  per_page?: number;
};

export type CategoriesRecipesGetAllCategoriesRecipesGetError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type CategoriesRecipesGetAllCategoriesRecipesGetResponse =
  Schemas.RecipesSchema[];

export type CategoriesRecipesGetAllCategoriesRecipesGetVariables = {
  queryParams: CategoriesRecipesGetAllCategoriesRecipesGetQueryParams;
} & OpenApIContext["fetcherOptions"];

export const fetchCategoriesRecipesGetAllCategoriesRecipesGet = (
  variables: CategoriesRecipesGetAllCategoriesRecipesGetVariables,
  signal?: AbortSignal
) =>
  openApIFetch<
    CategoriesRecipesGetAllCategoriesRecipesGetResponse,
    CategoriesRecipesGetAllCategoriesRecipesGetError,
    undefined,
    {},
    CategoriesRecipesGetAllCategoriesRecipesGetQueryParams,
    {}
  >({ url: "/categories_recipes", method: "get", ...variables, signal });

export const useCategoriesRecipesGetAllCategoriesRecipesGet = <
  TData = CategoriesRecipesGetAllCategoriesRecipesGetResponse
>(
  variables: CategoriesRecipesGetAllCategoriesRecipesGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      CategoriesRecipesGetAllCategoriesRecipesGetResponse,
      CategoriesRecipesGetAllCategoriesRecipesGetError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useOpenApIContext(options);
  return reactQuery.useQuery<
    CategoriesRecipesGetAllCategoriesRecipesGetResponse,
    CategoriesRecipesGetAllCategoriesRecipesGetError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/categories_recipes",
      operationId: "categoriesRecipesGetAllCategoriesRecipesGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchCategoriesRecipesGetAllCategoriesRecipesGet(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type SearchRecipesByDescriptionSearchRecipesByDescriptionGetQueryParams =
  {
    /**
     * Текст для поиска в описании рецепта
     */
    description_query: string;
    /**
     * Номер страницы, стандартно 1
     *
     * @default 1
     */
    page?: number;
    /**
     * Количество выгружаемых рецептов, стандартно 5
     *
     * @default 5
     */
    per_page?: number;
  };

export type SearchRecipesByDescriptionSearchRecipesByDescriptionGetError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type SearchRecipesByDescriptionSearchRecipesByDescriptionGetResponse =
  Schemas.RecipesSchema[];

export type SearchRecipesByDescriptionSearchRecipesByDescriptionGetVariables = {
  queryParams: SearchRecipesByDescriptionSearchRecipesByDescriptionGetQueryParams;
} & OpenApIContext["fetcherOptions"];

export const fetchSearchRecipesByDescriptionSearchRecipesByDescriptionGet = (
  variables: SearchRecipesByDescriptionSearchRecipesByDescriptionGetVariables,
  signal?: AbortSignal
) =>
  openApIFetch<
    SearchRecipesByDescriptionSearchRecipesByDescriptionGetResponse,
    SearchRecipesByDescriptionSearchRecipesByDescriptionGetError,
    undefined,
    {},
    SearchRecipesByDescriptionSearchRecipesByDescriptionGetQueryParams,
    {}
  >({
    url: "/search_recipes_by_description",
    method: "get",
    ...variables,
    signal,
  });

export const useSearchRecipesByDescriptionSearchRecipesByDescriptionGet = <
  TData = SearchRecipesByDescriptionSearchRecipesByDescriptionGetResponse
>(
  variables: SearchRecipesByDescriptionSearchRecipesByDescriptionGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      SearchRecipesByDescriptionSearchRecipesByDescriptionGetResponse,
      SearchRecipesByDescriptionSearchRecipesByDescriptionGetError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useOpenApIContext(options);
  return reactQuery.useQuery<
    SearchRecipesByDescriptionSearchRecipesByDescriptionGetResponse,
    SearchRecipesByDescriptionSearchRecipesByDescriptionGetError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/search_recipes_by_description",
      operationId: "searchRecipesByDescriptionSearchRecipesByDescriptionGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchSearchRecipesByDescriptionSearchRecipesByDescriptionGet(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type сategoriesGetAllCategoriesGetError =
  Fetcher.ErrorWrapper<undefined>;

export type сategoriesGetAllCategoriesGetResponse = Schemas.CategoriesSchema[];

export type сategoriesGetAllCategoriesGetVariables =
  OpenApIContext["fetcherOptions"];

export const fetchсategoriesGetAllCategoriesGet = (
  variables: сategoriesGetAllCategoriesGetVariables,
  signal?: AbortSignal
) =>
  openApIFetch<
    сategoriesGetAllCategoriesGetResponse,
    сategoriesGetAllCategoriesGetError,
    undefined,
    {},
    {},
    {}
  >({ url: "/categories", method: "get", ...variables, signal });

export const useCategoriesGetAllCategoriesGet = <
  TData = сategoriesGetAllCategoriesGetResponse
>(
  variables: сategoriesGetAllCategoriesGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      сategoriesGetAllCategoriesGetResponse,
      сategoriesGetAllCategoriesGetError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useOpenApIContext(options);
  return reactQuery.useQuery<
    сategoriesGetAllCategoriesGetResponse,
    сategoriesGetAllCategoriesGetError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/categories",
      operationId: "\u0441ategoriesGetAllCategoriesGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchсategoriesGetAllCategoriesGet(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type RecipeGetRecipeGetQueryParams = {
  recipe_id: number;
};

export type RecipeGetRecipeGetError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type RecipeGetRecipeGetVariables = {
  queryParams: RecipeGetRecipeGetQueryParams;
} & OpenApIContext["fetcherOptions"];

export const fetchRecipeGetRecipeGet = (
  variables: RecipeGetRecipeGetVariables,
  signal?: AbortSignal
) =>
  openApIFetch<
    Schemas.RecipeIngredientsSchema,
    RecipeGetRecipeGetError,
    undefined,
    {},
    RecipeGetRecipeGetQueryParams,
    {}
  >({ url: "/recipe", method: "get", ...variables, signal });

export const useRecipeGetRecipeGet = <TData = Schemas.RecipeIngredientsSchema>(
  variables: RecipeGetRecipeGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.RecipeIngredientsSchema,
      RecipeGetRecipeGetError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useOpenApIContext(options);
  return reactQuery.useQuery<
    Schemas.RecipeIngredientsSchema,
    RecipeGetRecipeGetError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/recipe",
      operationId: "recipeGetRecipeGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchRecipeGetRecipeGet({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type AuthJwtLoginAuthJwtLoginPostError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ErrorModel;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type AuthJwtLoginAuthJwtLoginPostVariables =
  OpenApIContext["fetcherOptions"];

export const fetchAuthJwtLoginAuthJwtLoginPost = (
  variables: AuthJwtLoginAuthJwtLoginPostVariables,
  signal?: AbortSignal
) =>
  openApIFetch<void, AuthJwtLoginAuthJwtLoginPostError, undefined, {}, {}, {}>({
    url: "/auth/jwt/login",
    method: "post",
    ...variables,
    signal,
  });

export const useAuthJwtLoginAuthJwtLoginPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      AuthJwtLoginAuthJwtLoginPostError,
      AuthJwtLoginAuthJwtLoginPostVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useOpenApIContext();
  return reactQuery.useMutation<
    void,
    AuthJwtLoginAuthJwtLoginPostError,
    AuthJwtLoginAuthJwtLoginPostVariables
  >({
    mutationFn: (variables: AuthJwtLoginAuthJwtLoginPostVariables) =>
      fetchAuthJwtLoginAuthJwtLoginPost({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type AuthJwtLogoutAuthJwtLogoutPostError =
  Fetcher.ErrorWrapper<undefined>;

export type AuthJwtLogoutAuthJwtLogoutPostVariables =
  OpenApIContext["fetcherOptions"];

export const fetchAuthJwtLogoutAuthJwtLogoutPost = (
  variables: AuthJwtLogoutAuthJwtLogoutPostVariables,
  signal?: AbortSignal
) =>
  openApIFetch<
    void,
    AuthJwtLogoutAuthJwtLogoutPostError,
    undefined,
    {},
    {},
    {}
  >({ url: "/auth/jwt/logout", method: "post", ...variables, signal });

export const useAuthJwtLogoutAuthJwtLogoutPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      AuthJwtLogoutAuthJwtLogoutPostError,
      AuthJwtLogoutAuthJwtLogoutPostVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useOpenApIContext();
  return reactQuery.useMutation<
    void,
    AuthJwtLogoutAuthJwtLogoutPostError,
    AuthJwtLogoutAuthJwtLogoutPostVariables
  >({
    mutationFn: (variables: AuthJwtLogoutAuthJwtLogoutPostVariables) =>
      fetchAuthJwtLogoutAuthJwtLogoutPost({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type RegisterRegisterAuthRegisterPostError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ErrorModel;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type RegisterRegisterAuthRegisterPostVariables = {
  body: Schemas.UserCreate;
} & OpenApIContext["fetcherOptions"];

export const fetchRegisterRegisterAuthRegisterPost = (
  variables: RegisterRegisterAuthRegisterPostVariables,
  signal?: AbortSignal
) =>
  openApIFetch<
    Schemas.UserRead,
    RegisterRegisterAuthRegisterPostError,
    Schemas.UserCreate,
    {},
    {},
    {}
  >({ url: "/auth/register", method: "post", ...variables, signal });

export const useRegisterRegisterAuthRegisterPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserRead,
      RegisterRegisterAuthRegisterPostError,
      RegisterRegisterAuthRegisterPostVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useOpenApIContext();
  return reactQuery.useMutation<
    Schemas.UserRead,
    RegisterRegisterAuthRegisterPostError,
    RegisterRegisterAuthRegisterPostVariables
  >({
    mutationFn: (variables: RegisterRegisterAuthRegisterPostVariables) =>
      fetchRegisterRegisterAuthRegisterPost({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type ResetForgotPasswordAuthForgotPasswordPostError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type ResetForgotPasswordAuthForgotPasswordPostVariables = {
  body: Schemas.BodyResetForgotPasswordAuthForgotPasswordPost;
} & OpenApIContext["fetcherOptions"];

export const fetchResetForgotPasswordAuthForgotPasswordPost = (
  variables: ResetForgotPasswordAuthForgotPasswordPostVariables,
  signal?: AbortSignal
) =>
  openApIFetch<
    void,
    ResetForgotPasswordAuthForgotPasswordPostError,
    Schemas.BodyResetForgotPasswordAuthForgotPasswordPost,
    {},
    {},
    {}
  >({ url: "/auth/forgot-password", method: "post", ...variables, signal });

export const useResetForgotPasswordAuthForgotPasswordPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      ResetForgotPasswordAuthForgotPasswordPostError,
      ResetForgotPasswordAuthForgotPasswordPostVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useOpenApIContext();
  return reactQuery.useMutation<
    void,
    ResetForgotPasswordAuthForgotPasswordPostError,
    ResetForgotPasswordAuthForgotPasswordPostVariables
  >({
    mutationFn: (
      variables: ResetForgotPasswordAuthForgotPasswordPostVariables
    ) =>
      fetchResetForgotPasswordAuthForgotPasswordPost({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type ResetResetPasswordAuthResetPasswordPostError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ErrorModel;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ResetResetPasswordAuthResetPasswordPostVariables = {
  body: Schemas.BodyResetResetPasswordAuthResetPasswordPost;
} & OpenApIContext["fetcherOptions"];

export const fetchResetResetPasswordAuthResetPasswordPost = (
  variables: ResetResetPasswordAuthResetPasswordPostVariables,
  signal?: AbortSignal
) =>
  openApIFetch<
    void,
    ResetResetPasswordAuthResetPasswordPostError,
    Schemas.BodyResetResetPasswordAuthResetPasswordPost,
    {},
    {},
    {}
  >({ url: "/auth/reset-password", method: "post", ...variables, signal });

export const useResetResetPasswordAuthResetPasswordPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      ResetResetPasswordAuthResetPasswordPostError,
      ResetResetPasswordAuthResetPasswordPostVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useOpenApIContext();
  return reactQuery.useMutation<
    void,
    ResetResetPasswordAuthResetPasswordPostError,
    ResetResetPasswordAuthResetPasswordPostVariables
  >({
    mutationFn: (variables: ResetResetPasswordAuthResetPasswordPostVariables) =>
      fetchResetResetPasswordAuthResetPasswordPost({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type VerifyRequestTokenAuthRequestVerifyTokenPostError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type VerifyRequestTokenAuthRequestVerifyTokenPostVariables = {
  body: Schemas.BodyVerifyRequestTokenAuthRequestVerifyTokenPost;
} & OpenApIContext["fetcherOptions"];

export const fetchVerifyRequestTokenAuthRequestVerifyTokenPost = (
  variables: VerifyRequestTokenAuthRequestVerifyTokenPostVariables,
  signal?: AbortSignal
) =>
  openApIFetch<
    void,
    VerifyRequestTokenAuthRequestVerifyTokenPostError,
    Schemas.BodyVerifyRequestTokenAuthRequestVerifyTokenPost,
    {},
    {},
    {}
  >({
    url: "/auth/request-verify-token",
    method: "post",
    ...variables,
    signal,
  });

export const useVerifyRequestTokenAuthRequestVerifyTokenPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      VerifyRequestTokenAuthRequestVerifyTokenPostError,
      VerifyRequestTokenAuthRequestVerifyTokenPostVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useOpenApIContext();
  return reactQuery.useMutation<
    void,
    VerifyRequestTokenAuthRequestVerifyTokenPostError,
    VerifyRequestTokenAuthRequestVerifyTokenPostVariables
  >({
    mutationFn: (
      variables: VerifyRequestTokenAuthRequestVerifyTokenPostVariables
    ) =>
      fetchVerifyRequestTokenAuthRequestVerifyTokenPost({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type VerifyVerifyAuthVerifyPostError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ErrorModel;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type VerifyVerifyAuthVerifyPostVariables = {
  body: Schemas.BodyVerifyVerifyAuthVerifyPost;
} & OpenApIContext["fetcherOptions"];

export const fetchVerifyVerifyAuthVerifyPost = (
  variables: VerifyVerifyAuthVerifyPostVariables,
  signal?: AbortSignal
) =>
  openApIFetch<
    Schemas.UserRead,
    VerifyVerifyAuthVerifyPostError,
    Schemas.BodyVerifyVerifyAuthVerifyPost,
    {},
    {},
    {}
  >({ url: "/auth/verify", method: "post", ...variables, signal });

export const useVerifyVerifyAuthVerifyPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserRead,
      VerifyVerifyAuthVerifyPostError,
      VerifyVerifyAuthVerifyPostVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useOpenApIContext();
  return reactQuery.useMutation<
    Schemas.UserRead,
    VerifyVerifyAuthVerifyPostError,
    VerifyVerifyAuthVerifyPostVariables
  >({
    mutationFn: (variables: VerifyVerifyAuthVerifyPostVariables) =>
      fetchVerifyVerifyAuthVerifyPost({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type UsersCurrentUserUsersMeGetError = Fetcher.ErrorWrapper<undefined>;

export type UsersCurrentUserUsersMeGetVariables =
  OpenApIContext["fetcherOptions"];

export const fetchUsersCurrentUserUsersMeGet = (
  variables: UsersCurrentUserUsersMeGetVariables,
  signal?: AbortSignal
) =>
  openApIFetch<
    Schemas.UserRead,
    UsersCurrentUserUsersMeGetError,
    undefined,
    {},
    {},
    {}
  >({ url: "/users/me", method: "get", ...variables, signal });

export const useUsersCurrentUserUsersMeGet = <TData = Schemas.UserRead>(
  variables: UsersCurrentUserUsersMeGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.UserRead,
      UsersCurrentUserUsersMeGetError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useOpenApIContext(options);
  return reactQuery.useQuery<
    Schemas.UserRead,
    UsersCurrentUserUsersMeGetError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/users/me",
      operationId: "usersCurrentUserUsersMeGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchUsersCurrentUserUsersMeGet(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type UsersPatchCurrentUserUsersMePatchError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ErrorModel;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type UsersPatchCurrentUserUsersMePatchVariables = {
  body?: Schemas.UserUpdate;
} & OpenApIContext["fetcherOptions"];

export const fetchUsersPatchCurrentUserUsersMePatch = (
  variables: UsersPatchCurrentUserUsersMePatchVariables,
  signal?: AbortSignal
) =>
  openApIFetch<
    Schemas.UserRead,
    UsersPatchCurrentUserUsersMePatchError,
    Schemas.UserUpdate,
    {},
    {},
    {}
  >({ url: "/users/me", method: "patch", ...variables, signal });

export const useUsersPatchCurrentUserUsersMePatch = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserRead,
      UsersPatchCurrentUserUsersMePatchError,
      UsersPatchCurrentUserUsersMePatchVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useOpenApIContext();
  return reactQuery.useMutation<
    Schemas.UserRead,
    UsersPatchCurrentUserUsersMePatchError,
    UsersPatchCurrentUserUsersMePatchVariables
  >({
    mutationFn: (variables: UsersPatchCurrentUserUsersMePatchVariables) =>
      fetchUsersPatchCurrentUserUsersMePatch({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type UsersUserUsersIdGetPathParams = {
  id: string;
};

export type UsersUserUsersIdGetError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type UsersUserUsersIdGetVariables = {
  pathParams: UsersUserUsersIdGetPathParams;
} & OpenApIContext["fetcherOptions"];

export const fetchUsersUserUsersIdGet = (
  variables: UsersUserUsersIdGetVariables,
  signal?: AbortSignal
) =>
  openApIFetch<
    Schemas.UserRead,
    UsersUserUsersIdGetError,
    undefined,
    {},
    {},
    UsersUserUsersIdGetPathParams
  >({ url: "/users/{id}", method: "get", ...variables, signal });

export const useUsersUserUsersIdGet = <TData = Schemas.UserRead>(
  variables: UsersUserUsersIdGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.UserRead,
      UsersUserUsersIdGetError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useOpenApIContext(options);
  return reactQuery.useQuery<Schemas.UserRead, UsersUserUsersIdGetError, TData>(
    {
      queryKey: queryKeyFn({
        path: "/users/{id}",
        operationId: "usersUserUsersIdGet",
        variables,
      }),
      queryFn: ({ signal }) =>
        fetchUsersUserUsersIdGet({ ...fetcherOptions, ...variables }, signal),
      ...options,
      ...queryOptions,
    }
  );
};

export type UsersPatchUserUsersIdPatchPathParams = {
  id: string;
};

export type UsersPatchUserUsersIdPatchError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ErrorModel;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type UsersPatchUserUsersIdPatchVariables = {
  body?: Schemas.UserUpdate;
  pathParams: UsersPatchUserUsersIdPatchPathParams;
} & OpenApIContext["fetcherOptions"];

export const fetchUsersPatchUserUsersIdPatch = (
  variables: UsersPatchUserUsersIdPatchVariables,
  signal?: AbortSignal
) =>
  openApIFetch<
    Schemas.UserRead,
    UsersPatchUserUsersIdPatchError,
    Schemas.UserUpdate,
    {},
    {},
    UsersPatchUserUsersIdPatchPathParams
  >({ url: "/users/{id}", method: "patch", ...variables, signal });

export const useUsersPatchUserUsersIdPatch = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserRead,
      UsersPatchUserUsersIdPatchError,
      UsersPatchUserUsersIdPatchVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useOpenApIContext();
  return reactQuery.useMutation<
    Schemas.UserRead,
    UsersPatchUserUsersIdPatchError,
    UsersPatchUserUsersIdPatchVariables
  >({
    mutationFn: (variables: UsersPatchUserUsersIdPatchVariables) =>
      fetchUsersPatchUserUsersIdPatch({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type UsersDeleteUserUsersIdDeletePathParams = {
  id: string;
};

export type UsersDeleteUserUsersIdDeleteError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type UsersDeleteUserUsersIdDeleteVariables = {
  pathParams: UsersDeleteUserUsersIdDeletePathParams;
} & OpenApIContext["fetcherOptions"];

export const fetchUsersDeleteUserUsersIdDelete = (
  variables: UsersDeleteUserUsersIdDeleteVariables,
  signal?: AbortSignal
) =>
  openApIFetch<
    undefined,
    UsersDeleteUserUsersIdDeleteError,
    undefined,
    {},
    {},
    UsersDeleteUserUsersIdDeletePathParams
  >({ url: "/users/{id}", method: "delete", ...variables, signal });

export const useUsersDeleteUserUsersIdDelete = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      UsersDeleteUserUsersIdDeleteError,
      UsersDeleteUserUsersIdDeleteVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useOpenApIContext();
  return reactQuery.useMutation<
    undefined,
    UsersDeleteUserUsersIdDeleteError,
    UsersDeleteUserUsersIdDeleteVariables
  >({
    mutationFn: (variables: UsersDeleteUserUsersIdDeleteVariables) =>
      fetchUsersDeleteUserUsersIdDelete({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type QueryOperation =
  | {
      path: "/countries";
      operationId: "countriesGetAllCountriesGet";
      variables: CountriesGetAllCountriesGetVariables;
    }
  | {
      path: "/favourites";
      operationId: "getFavouritesFavouritesGet";
      variables: GetFavouritesFavouritesGetVariables;
    }
  | {
      path: "/countries_recipes";
      operationId: "countriesRecipesGetAllCountriesRecipesGet";
      variables: CountriesRecipesGetAllCountriesRecipesGetVariables;
    }
  | {
      path: "/categories_recipes";
      operationId: "categoriesRecipesGetAllCategoriesRecipesGet";
      variables: CategoriesRecipesGetAllCategoriesRecipesGetVariables;
    }
  | {
      path: "/search_recipes_by_description";
      operationId: "searchRecipesByDescriptionSearchRecipesByDescriptionGet";
      variables: SearchRecipesByDescriptionSearchRecipesByDescriptionGetVariables;
    }
  | {
      path: "/categories";
      operationId: "\u0441ategoriesGetAllCategoriesGet";
      variables: сategoriesGetAllCategoriesGetVariables;
    }
  | {
      path: "/recipe";
      operationId: "recipeGetRecipeGet";
      variables: RecipeGetRecipeGetVariables;
    }
  | {
      path: "/users/me";
      operationId: "usersCurrentUserUsersMeGet";
      variables: UsersCurrentUserUsersMeGetVariables;
    }
  | {
      path: "/users/{id}";
      operationId: "usersUserUsersIdGet";
      variables: UsersUserUsersIdGetVariables;
    };
